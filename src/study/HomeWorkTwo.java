package study;

import java.util.Arrays;

/**
 * Класс предназначен для второй домашней работы посвященной циклам, массивам. Хотя может что и упустил.
 */
public class HomeWorkTwo {
    /*
    Метод change - предназначен для замены значений в массиве arr с помощью цикла for.
    В цикле фор мы задаем переменную i, которая и приравнием ее к нулю. Это позволяетее использовать
     для перебора индексов массива в итерации.После ай увеличивается на 1. Условие же нам помогает уложится ровно в
     длинну массива используя метод ленгф, используя которы мы можем не думать о длинне массива( встроенный метод)

     */
    public static void change(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == 1) {
                arr[i] = 0;
            } else if (arr[i] == 0) {
                arr[i] = 1;
            }
        }
    }
/*
Метод creatArrayAndGoToStepThree принимает в себя аргумент в видде целочисленного массива.Массив пустой.
 Имеет значение 8.(я так понял 8 это восемь областей памяти выделеных размером 4 байта). С помощью цикла фор мы
 заполняем этот масив. Каждая последующая область (индексом которой является ай и приращивается на единицу с итерацией)
 умножается на три(то есть имеет шаг 3). Значению массива сразу присвается новое значение. Как только ай = длинне метода
цикл завершается.

 */
    public static void creatArrayAndGoToStepThree(int[] array) {
        for(int i = 0;i < array.length; i++) {
            array[i] = i * 3;
        }
    }
    /*
    С помощью цикла фор, в методе forForNumberLessThanANumber, мы перебираем по индексу весь массив и если его значение
    меньше 6 умножаем на 2.  I выступает в роли индекса как и в предыдущих заданиях. Приращается на единицу с каждой
    итерацией. В теле же условие при котором умножение будет выполняться.
     */
    public static void forForNumberLessThanANumber(int[] arrays){
        for (int i = 0;i < arrays.length; i ++){
            if (arrays[i] < 6){
                arrays[i] = arrays[i] * 2;
            }
        }
    }
/*
Создать квадратный двумерный целочисленный массиви с помощью циклов заполнить его по диаганали. Мозг мне сьела эта
история. В прошлый раз на питоне я забил болт на нее. без гугла не решил.
 */
    public static void fillTable(int[][] table){

        for(int i = 0; i < table.length; i++){
            for(int j = 0; j < table[i].length; j++){
                if (i==j || j == table.length - i - 1){
                    table[i][j] = 1;
                }else {
                    table[i][j] = 0;
                }

                }
            }
        }
        /*
        Задать одномерный массив и найти в нем минимальный и максимальный элемент.
         */
        public static int min(int [] veriables) {// возвращаемое значение сделал инт
            int minima = 0;//Объявил переменную
            for (int i = 0; i < veriables.length; i++) {//задан цикл фор
                // его счетчик равен нулю счетчик меньше длинный строки и прирастает постле итераций на 1
                if (minima > veriables[i]) {//говорим что если минима больше числа массива то перезаписываем минима
                    minima = veriables[i];


                }
            }
            return minima;//возвращаем значение в переменную veriables
        }

    public static int max(int [] veriables){//Задаем возвращаемое значение как интовое в методе макс в который передается
        //переменная veriables
        int maxima = 0;// иницилизируем переменную максима с нулевым значением
        for(int i = 0; i <veriables.length; i++){ //Задаем цикл фор с нулевым значением условием  меньше длинны
            //массива и приращением после итерации на 1.
            if (maxima < veriables[i]){ //если максима меньше значения эл-та массива с индексом ай
                maxima = veriables[i]; // то пресваиваем значение эл-та массива переменной максима
            }
        }
        return maxima;//возвращаем значениев переменную с применненым методом.(результат)
    }



    /*
    Написать метод, в которые передается одномерный целочисленный массив, метод должен вернуть тру,
    если в массиве есть место в котором сумма левой и правой части равны. Пример [1,1,1,2,1 - true, [1,2,1,2,1] - false.
     */
    public static boolean equalityOfTheParties (int [] sides) { /*Иницилизация метода, с возвращаемым значением boolean,
    входным параметром которого является целочисленный массив.
    */
        int num = 0; //иницилизируем переменную.
        int subtraction = 0; // иницилизируем переменную
       for (int i = 0; i < sides.length; i++){ // запускаем цикл для подсчета суммы всех эл-ов массива
           num = num + sides[i]; // Здесь собственно она и считается
       }
       for (int i = 0; i < sides.length; i ++){ //иницилизируется второй цикл
           subtraction = subtraction + sides[i]; //используется вторая переменная куда складываеся промежуточная сумма
           // эл-ов массива
           if (subtraction == num - subtraction){ // задется условие сравнения, где разность из всей суммы эл-ов массива
               // и суммы сложеных уже эл-ов массива будет равна.
               return true; //если это так то возвращаем правду
           }
       } return false; //Если же нет то лож.
    }
    /*написать метод, которому подаеться на вход одномерный массив и число н( может быть + и -)
    при этом метод должен сместить все эллементы массива на н позицийю Нельзя пользоваться вспомогательными массивами.
     */

    public static void moveElements(int[] array, int number) { // на вход два аргумента на выход значение массива
        //многочисленного
        if (number > 0) { // если число больше нуля

            for (int i = 0; i < number; i++) { // число итераций меньше входного числа, приросто единица в цикл.
                int last = array[array.length - 1]; //  сохраняем последний элемент в переменной ласт
                for (int j = array.length - 1; j > 0; j--) { // создаем вложенный цикл
                    // с каждой итерацией счетчик уменьшается. В общем мы смещаем весь массив на длинну строки
                    //вправо а потом хвост переписываем в начало строкой ниже и количество итераций равно намбер
                    array[j] = array[j - 1];
                }
                array[0] = last;//
            }
        } else if (number < 0) {
            for (int i = 0; i > number; i--) { // число итераций меньше входного числа, приросто единица в цикл.
                int first = array[0]; //  сохраняем последний элемент в переменной ласт
                for (int j = 0; j < array.length - 1; j++) { // создаем вложенный цикл
                    //элемента. с каждой итерацией счетчик уменьшается.
                    array[j] = array[j + 1];
                }
                array[array.length - 1] = first; //запись начала в хвост.
            }
        }
    }
// До сих пор каша с этим)


/*
    Метод мейн вход в программу.
     1)Для метода ченж он активирует массив арр,с последующим применением и печатью данных
    массива а не ссылки из за использования Арейстустрин с аргументом ввиде измененного массива арр.

    2) Для метода создания массива с шагом 3, иницилизирует пустой метод арей с количеством 8 интов. Применяет метод
    и далее выводит на печать само наполнение массива.

    3)Для метода forForNumberLessThanANumber иницилизируется массив arrays, который прогоняется через цикл фор. Задача
    в том что бы числа которые в массиве меньше 6 умножить на 2,

    4)Иницилизируем переменную размерЩ(size) - для избежания магических чисел. Иницируем двумерный квадратный массив
    table. Вызываем его с применением метода и выводим на печать.

    5) Иницилизация одмомерного целочисленного массива. Иницилизация двух переменных в которые мы помести результат
    который нам вернут методы мин и макс и отправляем их на печать.

     */
        public static void main( String[] args){
            int[] arr = {1, 0, 0, 1, 1, 0, 1};
            change(arr);
            System.out.println(Arrays.toString(arr));

            int size = 8;
            int[] array = new int[size];
            creatArrayAndGoToStepThree(array);
            System.out.println(Arrays.toString(array));

            int[] arrays = {1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1};
            forForNumberLessThanANumber(arrays);
            System.out.println(Arrays.toString(arrays));

            int sizes = 4;
            int[] [] table = new int [sizes] [sizes];
            fillTable(table);
            System.out.println(Arrays.deepToString(table));

            int[] ver = {1, 2, 3, 111, 0};// обьявляем массив целочисленный
            int num = max(ver); //иницилизируем переменную в которой будет храниться результат применения метода к массиву
            int number = min(ver); //иницилизируем переменную в которой будет храниться результат применения метода к массиву
            System.out.println("Минимальное число - " + number);
            System.out.println("Максимальное число - " + num);

            int[] sides = {7, 8, 6, 6, 2}; // одномерный целочисленный массив для передачи в массив equalityOfTheParties
            System.out.println(equalityOfTheParties(sides));/* применение метода equalityOfTheParties к sides и вывод на
            печать */

            int[] arrayA = {1, 2, 3, 4, 5, 6};// массив
            int numN= -2;// число н
            moveElements(arrayA, numN);//иницилизация метода
            System.out.println(Arrays.toString(arrayA));//печать результата действия метода
        }
}